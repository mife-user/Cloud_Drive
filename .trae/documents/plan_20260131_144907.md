# Docker启动配置方案（简化版）

## 当前状态分析

- `docker-compose.yml` 文件已存在且配置完整
- 缺少 `Dockerfile` 文件，无法构建应用镜像
- 需要创建简化的Docker构建和启动配置

## 实现方案

### 步骤1：创建Dockerfile文件

```dockerfile
# Dockerfile
FROM golang:1.25-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY go.mod go.sum ./

# 下载依赖
RUN go mod download

# 复制源代码
COPY . .

# 构建应用
RUN CGO_ENABLED=0 GOOS=linux go build -o cloud_drive ./cmd/main.go

# 最终镜像
FROM alpine:latest

WORKDIR /app

# 复制构建产物
COPY --from=builder /app/cloud_drive .

# 创建必要的目录
RUN mkdir -p logs storage

# 暴露端口
EXPOSE 8080

# 启动应用
CMD ["./cloud_drive"]
```

### 步骤2：保持docker-compose.yml配置不变

**当前配置已经很完整**，包含了：
- 应用服务的完整环境变量配置
- MySQL数据库服务
- Redis缓存服务
- 网络配置和卷挂载

### 步骤3：创建启动脚本

```bash
# start-docker.sh
#!/bin/bash

# 停止并移除旧容器
docker-compose down

# 构建新镜像
docker-compose build

# 启动服务
docker-compose up -d

# 查看启动状态
docker-compose ps

# 查看日志
docker-compose logs -f
```

### 步骤4：创建停止脚本

```bash
# stop-docker.sh
#!/bin/bash

# 停止服务
docker-compose down

# 查看状态
docker-compose ps
```

## 技术要点

### Dockerfile配置要点

1. **多阶段构建**：
   - 使用golang镜像构建应用
   - 使用alpine镜像作为最终运行环境
   - 减小最终镜像体积

2. **目录结构**：
   - 创建必要的目录（logs、storage）
   - 确保应用有正确的存储路径

3. **环境变量**：
   - 通过docker-compose.yml传递环境变量
   - 避免在Dockerfile中硬编码敏感信息

### docker-compose配置要点

1. **网络配置**：
   - 使用自定义网络 `cloudpan-net`
   - 确保服务间可以相互通信

2. **卷配置**：
   - 持久化MySQL数据
   - 持久化Redis数据
   - 挂载日志目录

3. **依赖管理**：
   - 使用 `depends_on` 确保服务启动顺序
   - MySQL和Redis在应用服务之前启动

## 启动和停止命令

### 启动服务

```bash
# 赋予脚本执行权限
chmod +x start-docker.sh

# 启动服务
./start-docker.sh
```

### 停止服务

```bash
# 赋予脚本执行权限
chmod +x stop-docker.sh

# 停止服务
./stop-docker.sh
```

### 手动命令

```bash
# 构建并启动
docker-compose up --build -d

# 查看日志
docker-compose logs -f cloudpan

# 查看所有服务状态
docker-compose ps

# 停止服务
docker-compose down
```

## 预期效果

1. **完整的Docker环境**：
   - 应用服务运行在容器中
   - MySQL和Redis服务就绪
   - 所有服务通过网络相互连接

2. **环境变量配置**：
   - 应用使用正确的配置
   - 数据库连接正常
   - Redis缓存可用

3. **文件存储**：
   - 上传的文件存储在容器的storage目录
   - 日志文件存储在挂载的logs目录

通过这套配置，你可以实现完整的Docker容器化部署，包括构建、启动、停止整个应用服务栈。